DR002 Test strategy for 3rd party dependencies {#dr_002}
==============================================

There are some issues which depend on each other and may be resolved by a common solution:

- dependencies of UUT to code incompatible to the test environment
- the granularity of "unit" tests envisioned

Context
-------

We automatically run tests using the "native" build environment.
The native build environment is the test environment available on standard desktop environments 
and on the continuous integration server.

Some of our code has *dependencies* to 3rd party libraries/code.
And some of those libraries may not be compatible to the native build environment.

It is not necessary to test 3rd party libraries themselves.

Challenges with stubbing library dependencies
---------------------------------------------

Stubbing library dependencies is technically possible but not effortless.
Libraries such as [ArduinoFake][] can simplify stubbing.
But currently we use extensions from the Espressif Arduino Core implementation.
Those are not covered by ArduinoFake.

We can use the framework [FakeIt][] to simplify mocking and stubbing.
This requires that an interface to the code to be "faked" is available.
Using FakeIt, mocks or basic stubs can be generated with low effort.

The used libraries do not (always) provide interfaces which are compatible to the test environment.
That means, in general, that one needs to manually define stubs for the 3rd party dependencies.

A precondition to successfully stub code is, that one can exclude it from compiling.

[ArduinoFake]: https://github.com/FabioBatSilva/ArduinoFake/ "a simple mocking framework for Arduino"
[FakeIt]: https://github.com/eranpeer/FakeIt "C++ mocking made easy. A simple yet very expressive, headers only library for c++ mocking."

Challenges with stubbing units using PlatformIO
-----------------------------------------------

It must be noted that the build management tool currently used (PlatformIO) does not 
support fine tuning the selection of sources to be compiled for test execution via the projects'
build configuration (`platformio.ini`).
This is attributable to how the [Library Dependency Finder (LDF)](https://docs.platformio.org/en/latest/librarymanager/ldf.html) of PlatformIO works.
Even with `lib_ldf_mode = off` a dependency will be compiled entirely.

[For examle](https://github.com/Task-Tracker-Systems/.github/wiki/Meeting-notes-2023%E2%80%9012%E2%80%9019#task-tracker-device) the option [`build_src_filter`](https://docs.platformio.org/en/latest/projectconf/sections/env/options/build/build_src_filter.html#build-src-filter) is not considered for test builds.

This is in particular relevant for testing individual units (i.e. classes) isolated from its dependencies.
Because, without further measures, PlatformIO will compile all other source code which is part of the library the UUT resides.

To partially compile (private) libraries (what we use to structure "packages", see 
[Implementing a Plug-in Architecture](<\ref plugin_architecture> "Implementing a Plug-in Architecture")
) one can use a [`library.json`][JSON] file in combination with the [`extraScript` option](https://docs.platformio.org/en/latest/manifests/library-json/fields/build/extrascript.html) to filter files depending on the target build system.
This is potentially effortful.

[JSON]: https://docs.platformio.org/en/latest/manifests/library-json/index.html "PlatformIO documentation of manifest file"

Option: Skip testing 3rd party library adapters
-----------------------------------------------

A possibility to reduce the need for manual definition of stubs, would be to avoid compiling code for tests which has dependencies to 3rd party code.
The code which is then not tested on the native test environment should be kept to a minimum.
*These are the 3rd party library adapters.*
This code should be as simple as possible to reduce the risk of introducing errors.
Those adapters are then excluded from testing using the native build environment.

Instead the adapters would have to be replaced with stubs or fakes while testing.

Possible Options
----------------

I conclude these are the possibilities:

1. Exclude only the 3rd party *dependencies* which are not compatible to the test environment.
   - → One would have to stub the excluded dependencies.
   - 👍 Highest test coverage as some adapters are tested as well.
   - 👎 One has to stub the interface of the dependency.
      The adapters were specially introduced to avoid the dependency to that interface.
2. Exclude the 3rd party *adapters* entirely.
   - → One would have to stub all the adapters.
   - 👎 Lowest test coverage.
   - 👍 The purpose of the adapters is to decouple our code from other dependencies.
3. Partially exclude the 3rd party *adapters* to dependencies which are not compatible to the test environment.  
   - → One would have to implement filters using `library.json` and extra scripts or create a dedicated package for those adapters; and stub the excluded the adapters.
   - 👍 Highest test coverage as some adapters are tested as well.
   - 👍 No additional dependency is introduced.

Decide on the granularity of tests
----------------------------------

### Option: test individual units

In order to be able to test individual units (classes, compilations units, ...) one would either have to filter libraries using the `library.json` manifest files and additional scripts or separate these units into dedicated libraries.

The former requires probably extensive effort. The latter does mean that the structural elements of packages in form of directories get lost.

### Option: test integrated units

Instead one could attempt to test features using units and, their dependencies to a certain degree.
For example one could test the interface of a unit while also indirectly testing its dependencies - under the condition that those are part of our own code.
Those dependencies which shall or can not be tested will be omitted from the build.
Omitted dependencies will need to be substituted by stubs.

This way one would test more code at once.
Some dependencies may not be required to be stubbed.
In general the test result is more coarse.
In order to achieve a high test coverage additional unit tests - following the same principle - but stimulating other interfaces, may be necessary.
For example if some paths depend on internal states.

Decision
========

Wir können entweder vom Framework abhängen oder eine Abstraktion vom Framework schreiben, was viel Boilerplate Code bedeutet.

Gerade da zu Testen sich die Arduino Library gut stubben lässt (ArduinoFake) -> Arduino erlauben.