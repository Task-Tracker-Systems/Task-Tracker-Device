DR002 Test strategy for 3rd party dependencies {#dr_002}
==============================================

Context
-------

We automatically run tests using the "native" build environment.
The native build environment is the test environment available on standard desktop environments 
and on the continuous integration server.

Some of our code has *dependencies* to 3rd party libraries/code.
And some of those libraries may not be compatible to the native build environment.

It is not necessary to test 3rd party libraries themselves.

Challenges with PlatformIO
--------------------------



It must be noted that the build management tool currently used (PlatformIO) does not 
support fine tuning the selection of sources to be compiled for test execution via the projects'
build configuration (`platformio.ini`).
This is attributable to how the [Library Dependency Finder (LDF)](https://docs.platformio.org/en/latest/librarymanager/ldf.html) of PlatformIO works.
Even with `lib_ldf_mode = off` a dependency will be compiled entirely.

[For examle](https://github.com/Task-Tracker-Systems/.github/wiki/Meeting-notes-2023%E2%80%9012%E2%80%9019#task-tracker-device) the option [`build_src_filter`](https://docs.platformio.org/en/latest/projectconf/sections/env/options/build/build_src_filter.html#build-src-filter) is not considered for test builds.

To partially compile (private) libraries (what we use to structure "packages", see 
[Implementing a Plug-in Architecture](<\ref plugin_architecture> "Implementing a Plug-in Architecture")
) one can use a [`library.json`][JSON] file in combination with the [`extraScript` option](https://docs.platformio.org/en/latest/manifests/library-json/fields/build/extrascript.html) to filter files depending on the target build system.
This is potentially effortful.

[JSON]: https://docs.platformio.org/en/latest/manifests/library-json/index.html "PlatformIO documentation of manifest file"

Challenges with stubbing
------------------------

Stubbing dependencies is technically possible but not effortless.
Libraries such as [ArduinoFake][] can simplify stubbing.
But currently we use extensions from the Espressif Arduino Core implementation.
Those are not covered by ArduinoFake.

The used libraries do not (always) provide interfaces which are compatible to the test environment.
That means, in general, that one needs to manually define stubs for the 3rd party dependencies.

[ArduinoFake]: https://github.com/FabioBatSilva/ArduinoFake/ "a simple mocking framework for Arduino"

Option: Skip testing 3rd party library adapters
-----------------------------------------------

A possibility to avoid stubbing would be to avoid compiling code for tests which has dependencies to 3rd party code.
The code which is then not tested on the native test environment should be kept to a minimum.
*These are the 3rd party library adapters.*
This code should be as simple as possible to reduce the risk of introducing errors.
Those adapters are then excluded from testing using the native build environment.

Summary
-------

I conclude these are the possibilities:

1. Exclude (private) libraries (in particular the 3rd party libraries adapter package) from tests which depend on libraries incompatible to the native build environment. Easiest solution; least code coverage.
2. Define `library.json` files for the (private) libraries to selectively exclude source files from testing which are incompatible to the build environment.
3. Attempt to stub dependencies which can not be compiled using the native build environment. Highest code coverage; highest effort.

Unter der Annahme, dass man die oben genannten Anpassungen über `library.json` nicht umsetzen möchte (ich gehe davon aus, dass es viel Arbeit ist), dann bleibt einem Folgendes übrig:

Wenn man zum *Unit Testen* kleinere Software-Teile compilieren möchte (z.B. Unit=class), dann müsste man für jede Klasse eine "lib" definieren. Das führt zu einem Verlust an Struktur und Übersichtlichkeit.

Oder man definiert die Unit nicht so streng/klein sondern statt dessen Unit=lib. Ein Unit Test braucht dann nicht so kleinteilig zu sein. Eine Schnittstelle deckt dann (indirekt) mehr Code ab. Im Bedarfsfall können trotzdem alle Schnittstellen zum Stimulieren der Unit genutzt werden. Allerdings kann weniger Verhalten durch Stubs simuliert werden. Bestimmte Pfade durch die Unit sind damit möglicherweise schwieriger zu testen. Z.B. wenn diese zustandsbasiert sind.

Decision
========

Wir können entweder vom Framework abhängen oder eine Abstraktion vom Framework schreiben, was viel Boilerplate Code bedeutet.

Gerade da zu Testen sich die Arduino Library gut stubben lässt (ArduinoFake) -> Arduino erlauben.