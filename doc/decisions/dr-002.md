DR002 Test strategy for 3rd party dependencies {#dr_002}
==============================================

Context
-------

We automatically run tests using the "native" build environment.
The native build environment is the test environment available on standard desktop environments 
and on the continuous integration server.

Some of our code has *dependencies* to 3rd party libraries/code.
And some of those libraries may not be compatible to the native build environment.

It is not necessary to test 3rd party libraries themselves.

Challenges with stubbing
------------------------

Stubbing dependencies is technically possible but not effortless.
Libraries such as [ArduinoFake][] can simplify stubbing.
But currently we use extensions from the Espressif Arduino Core implementation.
Those are not covered by ArduinoFake.

We can use the framework [FakeIt][] to simplify mocking and stubbing.
This requires that an interface to the code to be "faked" is available.
Using FakeIt, mocks or basic stubs can be generated with low effort.

The used libraries do not (always) provide interfaces which are compatible to the test environment.
That means, in general, that one needs to manually define stubs for the 3rd party dependencies.

A precondition to successfully stub code is, that one can exclude it from compiling.

[ArduinoFake]: https://github.com/FabioBatSilva/ArduinoFake/ "a simple mocking framework for Arduino"
[FakeIt]: https://github.com/eranpeer/FakeIt "C++ mocking made easy. A simple yet very expressive, headers only library for c++ mocking."

Challenges with PlatformIO
--------------------------

It must be noted that the build management tool currently used (PlatformIO) does not 
support fine tuning the selection of sources to be compiled for test execution via the projects'
build configuration (`platformio.ini`).
This is attributable to how the [Library Dependency Finder (LDF)](https://docs.platformio.org/en/latest/librarymanager/ldf.html) of PlatformIO works.
Even with `lib_ldf_mode = off` a dependency will be compiled entirely.

[For examle](https://github.com/Task-Tracker-Systems/.github/wiki/Meeting-notes-2023%E2%80%9012%E2%80%9019#task-tracker-device) the option [`build_src_filter`](https://docs.platformio.org/en/latest/projectconf/sections/env/options/build/build_src_filter.html#build-src-filter) is not considered for test builds.

To partially compile (private) libraries (what we use to structure "packages", see 
[Implementing a Plug-in Architecture](<\ref plugin_architecture> "Implementing a Plug-in Architecture")
) one can use a [`library.json`][JSON] file in combination with the [`extraScript` option](https://docs.platformio.org/en/latest/manifests/library-json/fields/build/extrascript.html) to filter files depending on the target build system.
This is potentially effortful.

[JSON]: https://docs.platformio.org/en/latest/manifests/library-json/index.html "PlatformIO documentation of manifest file"

Option: Skip testing 3rd party library adapters
-----------------------------------------------

A possibility to reduce the need for manual definition of stubs, would be to avoid compiling code for tests which has dependencies to 3rd party code.
The code which is then not tested on the native test environment should be kept to a minimum.
*These are the 3rd party library adapters.*
This code should be as simple as possible to reduce the risk of introducing errors.
Those adapters are then excluded from testing using the native build environment.

Instead the adapters would have to be replaced with stubs or fakes while testing.

Possible Options
----------------

I conclude these are the possibilities:

1. Exclude only the 3rd party *dependencies* which are not compatible to the test environment.
   - → One would have to stub the excluded dependencies.
   - 👍 Highest test coverage as some adapters are tested as well.
   - 👎 One has to stub the interface of the dependency.
      The adapters were specially introduced to avoid the dependency to that interface.
2. Exclude the 3rd party *adapters* entirely.
   - → One would have to stub all the adapters.
   - 👎 Lowest test coverage.
   - 👍 The purpose of the adapters is to decouple our code from other dependencies.
3. Partially exclude the 3rd party *adapters* to dependencies which are not compatible to the test environment.  
   - → One would have to implement filters using `library.json` and extra scripts or create a dedicated package for those adapters; and stub the excluded the adapters.
   - 👍 Highest test coverage as some adapters are tested as well.
   - 👍 No additional dependency is introduced.


---

1. Exclude (private) libraries (in particular the 3rd party libraries adapter package) from tests which depend on libraries incompatible to the native build environment.
The excluded files would have to be stubbed.
This would be the easiest solution but with the least code coverage of the tests.
2. Define `library.json` files for the (private) libraries to selectively exclude source files from testing which are incompatible to the build environment.
Excluded files would have to be stubbed.
3. Attempt to stub dependencies which can not be compiled using the native build environment. Highest code coverage; highest effort.

Unter der Annahme, dass man die oben genannten Anpassungen über `library.json` nicht umsetzen möchte (ich gehe davon aus, dass es viel Arbeit ist), dann bleibt einem Folgendes übrig:

Wenn man zum *Unit Testen* kleinere Software-Teile compilieren möchte (z.B. Unit=class), dann müsste man für jede Klasse eine "lib" definieren. Das führt zu einem Verlust an Struktur und Übersichtlichkeit.

Oder man definiert die Unit nicht so streng/klein sondern statt dessen Unit=lib. Ein Unit Test braucht dann nicht so kleinteilig zu sein. Eine Schnittstelle deckt dann (indirekt) mehr Code ab. Im Bedarfsfall können trotzdem alle Schnittstellen zum Stimulieren der Unit genutzt werden. Allerdings kann weniger Verhalten durch Stubs simuliert werden. Bestimmte Pfade durch die Unit sind damit möglicherweise schwieriger zu testen. Z.B. wenn diese zustandsbasiert sind.

Decision
========

Wir können entweder vom Framework abhängen oder eine Abstraktion vom Framework schreiben, was viel Boilerplate Code bedeutet.

Gerade da zu Testen sich die Arduino Library gut stubben lässt (ArduinoFake) -> Arduino erlauben.