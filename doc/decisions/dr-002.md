DR002 Test strategy for 3rd party dependencies {#dr_001}
==============================================

Context
-------

We automatically run tests using the "native" build environment.
The native build environment is the test environment available on standard desktop environments 
and on the continuous integration server.

Some of our code has *dependencies* to 3rd party libraries/code.
And some of those libraries may not be compatible to the native build environment.

It is not necessary to test 3rd party libraries themselves.

Challenges with PlatformIO
--------------------------



It must be noted that the build management tool currently used (PlatformIO) does not 
support fine tuning the selection of sources to be compiled for test execution via the projects'
build configuration (`platformio.ini`).

In particular to partially compile (private) libraries (what we use to structure "packages", see \ref plugin_architecture)



Libraries can be partially compiled using a [`library.json`][JSON] file to filter files depending on
the target build system.
Apart from this, libraries are build as a whole.

[JSON]: https://docs.platformio.org/en/latest/manifests/library-json/index.html "PlatformIO documentation of manifest file"

Challenges with stubbing
------------------------

Mocking dependencies is technically possible but not effortless.
Libraries such as [ArduinoFake][] can simplify mocking.
But currently we use extensions from the Espressif Arduino framework.
Those are not covered by ArduinoFake.

The used libraries do not (always) provide interfaces which are compatible to the test environment.
That means, in general, that one needs to implement stubs for the 3rd party dependencies.

[ArduinoFake]: https://github.com/FabioBatSilva/ArduinoFake/ "a simple mocking framework for Arduino"

Option: Skip testing 3rd party library adapters
-----------------------------------------------

A possibility to avoid stubbing would be to avoid compiling code for tests which has dependencies to 3rd party code.
The code which is then not tested on the native test environment should be kept to a minimum.
*These are the 3rd party library adapters.*
This code should be as simple as possible to reduce the risk of introducing errors.
Those adapters are then excluded from testing using the native build environment.

Summary
-------

I conclude these are the possibilities:

1. Exclude (private) libraries (in particular the 3rd party libraries adapter package) from tests which depend on libraries incompatible to the native build environment. Easiest solution; least code coverage.
2. Define `library.json` files for the (private) libraries to selectively exclude source files from testing which are incompatible to the build environment.
3. Attempt to stub dependencies which can not be compiled using the native build environment. Highest code coverage; highest effort.

Eine *Erkenntnis*, welche wohl schon ziemlich ğŸ˜‰ gesichert ist: Man kann private libs (unsere _packages_; Uncle Bob's "software layer"; PlatformIO's `lib_dir`) nur partiell compilieren, wenn man den build-Vorgang Ã¼ber `library.json` und `extraScript` anpasst (potentiell aufwÃ¤ndig!). Das liegt daran, wie der Library Dependency Finder (LDF) von PlatformIO funktioniert (selbst bei `lib_ldf_mode = off` wird eine AbhÃ¤ngigkeit (lib) ohne Anpassung (s.o.) immer _komplett_ gebaut). Unter der Annahme, dass man die oben genannten Anpassungen Ã¼ber `library.json` nicht umsetzen mÃ¶chte (ich gehe davon aus, dass es viel Arbeit ist), dann bleibt einem Folgendes Ã¼brig:

Wenn man zum *Unit Testen* kleinere Software-Teile compilieren mÃ¶chte (z.B. Unit=class), dann mÃ¼sste man fÃ¼r jede Klasse eine "lib" definieren. Das fÃ¼hrt zu einem Verlust an Struktur und Ãœbersichtlichkeit.

Oder man definiert die Unit nicht so streng/klein sondern statt dessen Unit=lib. Ein Unit Test braucht dann nicht so kleinteilig zu sein. Eine Schnittstelle deckt dann (indirekt) mehr Code ab. Im Bedarfsfall kÃ¶nnen trotzdem alle Schnittstellen zum Stimulieren der Unit genutzt werden. Allerdings kann weniger Verhalten durch Stubs simuliert werden. Bestimmte Pfade durch die Unit sind damit mÃ¶glicherweise schwieriger zu testen. Z.B. wenn diese zustandsbasiert sind.

Decision
========

Wir kÃ¶nnen entweder vom Framework abhÃ¤ngen oder eine Abstraktion vom Framework schreiben, was viel Boilerplate Code bedeutet.

Gerade da zu Testen sich die Arduino Library gut stubben lÃ¤sst (ArduinoFake) -> Arduino erlauben.