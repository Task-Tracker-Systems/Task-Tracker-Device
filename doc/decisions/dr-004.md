# DR004 Direct usage of Hardware Abstraction Layer

## Context

Currently we violate the requirement to use libraries and frameworks only through adapters, as it is required by the objectives of the software architecture (see 
[relevant section in Software Architecture](<\ref flexible_structure> "relevant section in Software Architecture"):
We currently use an implementation of the [ArduinoCore-API][ACA] (ACA) as a hardware abstraction layer (HAL) from outside of the adapters layer.
More specifically we use an implementation of the ACA from Espressif coined for ESP32s.

It is generally assumed that using HALs is only necessary from the
[board adapters package](<\ref board_adapters> "board adapters package").

[ACA]: https://github.com/arduino/ArduinoCore-API

## Options

There are several options on how to resolve this violation of our own rules.

### Option 1

Abide to the current guidelines.

According to the current state of the software architecture we should use the 3rd party HAL indirectly through adapters.
Those adapters would reside in the 
[3rd party adapters package](<\ref third_party_adapters> "3rd party adapters package").

#### Option 1a)

For an object oriented (OO) variant, defining an interface and inheriting from it, it would require to:

- define one or several interfaces inside the
  [board adapters package](<\ref board_adapters> "board adapters package")
  (header files)
- implement those as adapters inside the
  [3rd party adapters package](<\ref third_party_adapters> "3rd party adapters package")
  (source files)
- define interfaces for the factories (see 
  [dependency injection](<\ref dependency_injection> "dependency injection")
  inside the
  [board adapters package](<\ref board_adapters> "board adapters package")
  (header files)
- implement those factories inside the
  [3rd party adapters package](<\ref third_party_adapters> "3rd party adapters package")
  (source files)

This is the usual way dependency injection and therefore the 
[dependency rule](<\ref interpretation_dependency_rule> "dependency rule")
is implemented.

#### Option 1b)

Instead of using an object oriented approach using inheritance, one could create an interface to the HAL based on free functions.

This option would require to:

- define one or several interfaces (free function declarations) inside the
  [board adapters package](<\ref board_adapters> "board adapters package")
  (header files)
- implement those as adapters inside the
  [3rd party adapters package](<\ref third_party_adapters> "3rd party adapters package")
  (source files)
- if the build configuration (see [`lib_ldf_mode`][1]) requires it, one may have to define 
  [proxy headers](<\ref proxy_header> "proxy headers")
  (header files)

Factories are not necessary because this approach does not rely on objects.

[1]: https://docs.platformio.org/en/latest/projectconf/sections/env/options/library/lib_ldf_mode.html "PlatformIO documentation of lib_ldf_mode"

#### Option 1c)

A hybrid approach (OO and free functions) is also possible.
This would fit well to the [ACA][] as is also consists of classes and free functions.

The steps required would be a mixture of those of options 1a) and 1b).

### Option 2

Change the current guidelines such that the direct dependency to 3rd party HALs is allowed within hardware related packages (which is currently only the 
[board adapters package](<\ref board_adapters> "board adapters package")).

This approach eliminates the requirement to define 3rd party adapters to the HAL.

In order to be able to test code depending on the [ACA][], the 3rd party interface needs to be stubbed.
For vanilla [ACA][], stubbing the proprietary interface can be greatly simplified by using [ArduinoFake][].
We use an [implementation of the Arduino Core API (ACA) specific for ESP32s by Espressif](https://github.com/espressif/arduino-esp32/) which extends the [ACA][].
Following the approach of this option, to directly use [ACA][] and [ArduinoFake][] for testing, we would need to deal with the extensions separately.
The following variants of this option, specifies different methods to cope with the extensions.

[ArduinoFake]: https://platformio.org/lib/show/1689/ArduinoFake "ArduinoFake in PlaftormIO's registry"

#### Option 2a)

Instead of directly using a modified Arduino interface (for example for a specific `class`), we use an adapter.
The adapters would be integrated just as for option 1.
But compared to option 1 this only needs to be done for those smallest indivisible interfaces which are not compatible to the vanilla [ACA][].

#### Option 2b)

At those places in the source code where extensions are used, we introduce conditionally compiled sections.
One section uses the modified version of the [ACA][], necessary for the productive code.
The alternative section is instead used when compiling for native tests.
It uses the vanilla [ACA][] which can be simply stubbed using [ArduinoFake][].

The selection of conditionally compiled sections is done using `constexpr if`, where possible.
Else the C preprocessor (CPP) is used for conditional inclusion (`#if`, ...).

